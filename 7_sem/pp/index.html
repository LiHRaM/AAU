<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming Paradigms - Notes at Aalborg University</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../intro.html">Intro</a></li><li class="chapter-item affix "><a href="../../structure.html">Structure</a></li><li class="spacer"></li><li class="chapter-item "><a href="../../1_sem/index.html"><strong aria-hidden="true">1.</strong> Semester 1</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../1_sem/ip/index.html"><strong aria-hidden="true">1.1.</strong> Imperative Programming</a></li><li class="chapter-item "><a href="../../1_sem/la/index.html"><strong aria-hidden="true">1.2.</strong> Linear Algebra</a></li><li class="chapter-item "><a href="../../1_sem/pbl/index.html"><strong aria-hidden="true">1.3.</strong> Problem Based Learning</a></li></ol></li><li class="chapter-item "><a href="../../2_sem/index.html"><strong aria-hidden="true">2.</strong> Semester 2</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../2_sem/cart/index.html"><strong aria-hidden="true">2.1.</strong> Computer Architecture</a></li><li class="chapter-item "><a href="../../2_sem/dm/index.html"><strong aria-hidden="true">2.2.</strong> Discrete Mathematics</a></li><li class="chapter-item "><a href="../../2_sem/oop/index.html"><strong aria-hidden="true">2.3.</strong> Object Oriented Programming</a></li></ol></li><li class="chapter-item "><a href="../../3_sem/index.html"><strong aria-hidden="true">3.</strong> Semester 3</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../3_sem/ad/index.html"><strong aria-hidden="true">3.1.</strong> Algorithms and Datastructures</a></li><li class="chapter-item "><a href="../../3_sem/deb/index.html"><strong aria-hidden="true">3.2.</strong> Design and Evaluation of User Interfaces</a></li><li class="chapter-item "><a href="../../3_sem/su/index.html"><strong aria-hidden="true">3.3.</strong> System's Development</a></li></ol></li><li class="chapter-item "><a href="../../4_sem/index.html"><strong aria-hidden="true">4.</strong> Semester 4</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../4_sem/loc/index.html"><strong aria-hidden="true">4.1.</strong> Languages and Compilers</a></li><li class="chapter-item "><a href="../../4_sem/os/index.html"><strong aria-hidden="true">4.2.</strong> Principles of Operating Systems and Concurrency</a></li><li class="chapter-item "><a href="../../4_sem/ss/index.html"><strong aria-hidden="true">4.3.</strong> Syntax and Semantics</a></li></ol></li><li class="chapter-item "><a href="../../5_sem/index.html"><strong aria-hidden="true">5.</strong> Semester 5</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../5_sem/cc/index.html"><strong aria-hidden="true">5.1.</strong> Computability and Complexity</a></li><li class="chapter-item "><a href="../../5_sem/mi/index.html"><strong aria-hidden="true">5.2.</strong> Machine Intelligence</a></li><li class="chapter-item "><a href="../../5_sem/se/index.html"><strong aria-hidden="true">5.3.</strong> Software Engineering</a></li></ol></li><li class="chapter-item "><a href="../../6_sem/index.html"><strong aria-hidden="true">6.</strong> Semester 6</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../6_sem/aad/index.html"><strong aria-hidden="true">6.1.</strong> Advanced Algorithms and Datastructures</a></li><li class="chapter-item "><a href="../../6_sem/db/index.html"><strong aria-hidden="true">6.2.</strong> Database Systems</a></li><li class="chapter-item "><a href="../../6_sem/ts/index.html"><strong aria-hidden="true">6.3.</strong> Theory of Science</a></li></ol></li><li class="chapter-item expanded "><a href="../../7_sem/index.html"><strong aria-hidden="true">7.</strong> Semester 7</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../7_sem/dis/index.html"><strong aria-hidden="true">7.1.</strong> Distributed Systems</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../7_sem/dis/8_blockchain.2.html"><strong aria-hidden="true">7.1.1.</strong> Blockchain Notes</a></li></ol></li><li class="chapter-item expanded "><a href="../../7_sem/pp/index.html" class="active"><strong aria-hidden="true">7.2.</strong> Programming Paradigms</a></li><li class="chapter-item "><a href="../../7_sem/tov/index.html"><strong aria-hidden="true">7.3.</strong> Test and Verification</a></li></ol></li><li class="chapter-item "><a href="../../8_sem/index.html"><strong aria-hidden="true">8.</strong> Semester 8</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../8_sem/sp/index.html"><strong aria-hidden="true">8.1.</strong> Selected Topics in Programming</a></li><li class="chapter-item "><a href="../../8_sem/wip/index.html"><strong aria-hidden="true">8.2.</strong> Web Information Processing</a></li><li class="chapter-item "><a href="../../8_sem/mdls/index.html"><strong aria-hidden="true">8.3.</strong> Mobile Data and Location-based Services</a></li><li class="chapter-item "><a href="../../8_sem/swi/index.html"><strong aria-hidden="true">8.4.</strong> Software Innovation</a></li><li class="chapter-item "><a href="../../8_sem/mhci/index.html"><strong aria-hidden="true">8.5.</strong> Mobile HCI</a></li></ol></li><li class="chapter-item "><a href="../../9_sem/index.html"><strong aria-hidden="true">9.</strong> Semester 9</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../9_sem/iret/index.html"><strong aria-hidden="true">9.1.</strong> IT Law</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../9_sem/iret/lec_1.html"><strong aria-hidden="true">9.1.1.</strong> Lecture 1</a></li><li class="chapter-item "><a href="../../9_sem/iret/lec_2.html"><strong aria-hidden="true">9.1.2.</strong> Lecture 2</a></li><li class="chapter-item "><a href="../../9_sem/iret/lec_3.html"><strong aria-hidden="true">9.1.3.</strong> Lecture 3</a></li><li class="chapter-item "><a href="../../9_sem/iret/lec_4.html"><strong aria-hidden="true">9.1.4.</strong> Lecture 4</a></li><li class="chapter-item "><a href="../../9_sem/iret/lec_5.html"><strong aria-hidden="true">9.1.5.</strong> Lecture 5</a></li><li class="chapter-item "><a href="../../9_sem/iret/lec_6.html"><strong aria-hidden="true">9.1.6.</strong> Lecture 6</a></li><li class="chapter-item "><a href="../../9_sem/iret/lec_7.html"><strong aria-hidden="true">9.1.7.</strong> Lecture 7</a></li><li class="chapter-item "><a href="../../9_sem/iret/lec_8.html"><strong aria-hidden="true">9.1.8.</strong> Lecture 8</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Notes at Aalborg University</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#programming-paradigms" id="programming-paradigms">Programming Paradigms</a></h1>
<h1><a class="header" href="#scheme---part-1" id="scheme---part-1">Scheme - Part 1</a></h1>
<h2><a class="header" href="#literature" id="literature">Literature</a></h2>
<ul>
<li><a href="https://www.scheme.com/tspl4/">The Scheme Programming Language</a></li>
<li><a href="https://people.cs.aau.dk/%7Enormark/pp-*/gjm.lambook88-3.pdf">An Introduction to Functional Programming Through Lambda Calculus</a></li>
</ul>
<h2><a class="header" href="#learning-goals" id="learning-goals">Learning Goals</a></h2>
<p>Establish an overall understanding of functional programming to understand the basic characteristics of Lisp.</p>
<ul>
<li>Expressions
<ul>
<li>Symbolic Expressions</li>
<li>Lambda Expressions</li>
</ul>
</li>
<li>Data Types
<ul>
<li>Lists</li>
</ul>
</li>
<li>Functions</li>
<li>Name Bindings</li>
</ul>
<h2><a class="header" href="#notes" id="notes">Notes</a></h2>
<pre><code class="language-scheme">;; This is a comment
(+ 1 1)
;; =&gt; 2
</code></pre>
<p>Defining a function using <code>define</code>.</p>
<pre><code class="language-scheme">;;; Define a function `plus`, which returns the sum of `param1` and `param2`.
(define (plus param1 param2) (+ param1 param2))
</code></pre>
<p>Alternatively:</p>
<pre><code class="language-scheme">&gt; (define plus (λ (param1 param2) (+ param1 param2)))
&gt; 
</code></pre>
<p>Using an arbitrary number of parameters, <code>x</code> is bound to the first, and <code>y</code> is bound to the rest.</p>
<pre><code class="language-scheme">&gt; (define (func x . y)
        y)
&gt; (func 1 2 3 4)
'(2 3 4)
</code></pre>
<h2><a class="header" href="#symbolic-expression" id="symbolic-expression">Symbolic Expression</a></h2>
<p>A Symbolic Expression, or an S-Expression, is one of two things:</p>
<ol>
<li>An atom, or</li>
<li>a pair <code>(a . b)</code> where both <code>a</code> and <code>b</code> are S-expressions.</li>
</ol>
<h2><a class="header" href="#lambda-expression" id="lambda-expression">Lambda Expression</a></h2>
<p>The Lambda Expression is a procedure which returns a procedure.</p>
<pre><code class="language-scheme">(λ (param) ; The body begins once the parameter parens is closed.
    param) ; Here we just return the parameter.
</code></pre>
<h2><a class="header" href="#name-binding" id="name-binding">Name Binding</a></h2>
<p>There are three types of name binding: <code>let</code>, <code>let*</code> and <code>letrec</code>.</p>
<pre><code class="language-scheme">;;; Let binding syntax
(let ((n1 m1)
     ...
     (nk mk))
     (body))

;;; Let binding example
(let ((a 1)
      (b 2))
    (+ a b))
</code></pre>
<p><code>let</code> bindings are syntactic sugar for lambda expressions, which provide the name bindings.
The above program is therefore rewritten as:</p>
<pre><code class="language-scheme">;;; Let syntax transformed to lambda
((λ (n1 .. nk) (body)) m1 .. mk)

;;; Let binding example transformed to lambda
((λ (a b) (+ a b)) 1 2)
</code></pre>
<p>Note that <code>letrec</code> is <em><strong>impure</strong></em>.</p>
<h1><a class="header" href="#scheme---part-2" id="scheme---part-2">Scheme - Part 2</a></h1>
<h2><a class="header" href="#tail-call-recursion" id="tail-call-recursion">Tail Call Recursion</a></h2>
<p>As opposed to normal recursion, tail call recursion requires the recursive call to be in the tail position.</p>
<pre><code class="language-scheme">
</code></pre>
<p>Scheme requires tail calls to be implemented as jumps, i.e. that no frames are wasted.</p>
<h2><a class="header" href="#higher-order-functions" id="higher-order-functions">Higher Order Functions</a></h2>
<p>Higher order functions are functions of order 2 or above, meaning they take parameters of order 1 or above.
In other words, higher order functions can take and return functions.</p>
<h3><a class="header" href="#map" id="map">Map</a></h3>
<p>Map takes a list, applies a function to each element and returns a list of the same length.</p>
<h3><a class="header" href="#filter" id="filter">Filter</a></h3>
<p>Filter takes a list and a predicate, returning a second list with only the elements where the predicate returns true.</p>
<h3><a class="header" href="#reduce" id="reduce">Reduce</a></h3>
<p>Reduce takes a list and a reduce function, folding the list until only a single element remains.</p>
<h3><a class="header" href="#zip" id="zip">Zip</a></h3>
<p>Zip takes two lists and a function, and uses the function to merge the two lists into a single list, which it returns.
The lists have to have the same length.</p>
<h2><a class="header" href="#currying" id="currying">Currying</a></h2>
<p>The idea behind currying is that each function only takes a single parameter.
Instead of the following:</p>
<pre><code class="language-scheme">(λ (a b c) (+ a b c))
</code></pre>
<p>A function would be implemented as a cascade of functions, such that:</p>
<pre><code class="language-scheme">(λ (a)
    (λ (b) 
        (λ (c) 
        (+ a b c))))
</code></pre>
<p>By then calling the function with less than 3 parameters, we receive a new function, which takes the rest of the parameters.
This allows us to compose functions more lazily, and is known as currying, after Haskell Curry.</p>
<h1><a class="header" href="#scheme---part-3" id="scheme---part-3">Scheme - Part 3</a></h1>
<h2><a class="header" href="#continuations" id="continuations">Continuations</a></h2>
<blockquote>
<p>A continuation of an expression <code>E</code> in a surrounding context <code>C</code> represents the future of the computation, which waits for, and depends on the value of <code>E</code>.
A contiuation is materialized as a function which takes a single parameter.</p>
</blockquote>
<p>Consider the snippet below, where the expression <code>(* 4 3)</code> is inside the context <code>(+ 5 E)</code>.
The continuation of <code>E</code> is <em>adding five to...</em>.</p>
<pre><code class="language-scheme">(+ 5 (* 4 3))
</code></pre>
<p>In other words:</p>
<pre><code class="language-scheme">(λ (E) (+ 5 E))
</code></pre>
<p>Explicitly capturing the expression <code>E</code> in the context <code>C</code>:</p>
<pre><code class="language-scheme">(+ 5 (call/cc (λ (cc) (* 4 3))))
</code></pre>
<p>Using the context <code>C</code> within the expression <code>E</code>:</p>
<pre><code class="language-scheme">&gt; (+ 5 (call/cc (λ (cc) (* 4 (cc 4)))))
9
</code></pre>
<p><em><strong>Note</strong></em>: In the above snippet, the only part which is actually evaluated is <code>(cc 4)</code>, where <code>cc</code> is the continuation <code>(+ 5 E)</code>, i.e. the expression is evaluated as <code>(+ 5 4)</code>.</p>
<h1><a class="header" href="#scheme---part-4" id="scheme---part-4">Scheme - Part 4</a></h1>
<h2><a class="header" href="#evaluation-order" id="evaluation-order">Evaluation Order</a></h2>
<p>Consider the following snippet:</p>
<pre><code class="language-scheme">(define (infinite-calculation)
    (infinite-calculation))
    
((λ (x) 1) (infinite-calculation))
</code></pre>
<p>What is the result of evaluating the fourth line?
Well, due to the evaluation order of Scheme, evaluation will loop forever, as the parameter is evaluated eagerly, i.e. before it is passed to the function.</p>
<h3><a class="header" href="#rewrite-rules" id="rewrite-rules">Rewrite Rules</a></h3>
<blockquote>
<p>The rewrite rules define semantic preserving transformations of expressions</p>
</blockquote>
<h4><a class="header" href="#alpha-rule" id="alpha-rule">Alpha Rule</a></h4>
<p>Formal parameters of a lambda expression can be substituted with other names which are not used as free names in the body.</p>
<h4><a class="header" href="#beta-rule" id="beta-rule">Beta Rule</a></h4>
<p>An application of a function can be substituted by the function body, in which the formal parameters are substituted by the corresponding actual parameters.
For example, consider the following snippet:</p>
<pre><code class="language-scheme">((λ (x) (+ x 1) 1) ; &lt;=&gt; (+ 1 1)
</code></pre>
<h4><a class="header" href="#eta-rule" id="eta-rule">Eta Rule</a></h4>
<p>A function <code>f</code>, which only passes its parameters on to another function <code>e</code>, can be substituted by <code>e</code>.
For example, consider the following snippet:</p>
<pre><code class="language-scheme">(λ (x) (e x)) ; &lt;=&gt; e
              ; where e is an other function
</code></pre>
<h4><a class="header" href="#normal-form" id="normal-form">Normal Form</a></h4>
<p>An expression is in <em>normal form</em> if it cannot be reduced further by beta and eta rewrites.
A normal form represents our intuition of the value of an expression.</p>
<h3><a class="header" href="#order-of-reductions" id="order-of-reductions">Order of Reductions</a></h3>
<p>Using the rewrite rules can be done in several ways, which is why the order of reductions has been standardized.</p>
<p>In order to demonstrate the difference between the two, consider the following snippet:</p>
<pre><code class="language-scheme">((λ (x y) (+ (* x x) (* y y)))
    (fak 5)
    (fib 10))
</code></pre>
<h4><a class="header" href="#normal-order" id="normal-order">Normal Order</a></h4>
<p>The first reduction to perform is the one at the outer level of the expression, i.e. evaluation by need.</p>
<ol>
<li>Beta rewrite lambda expression</li>
</ol>
<pre><code class="language-scheme">(+ (* (fak 5) (fak 5) (* (fib 10) (fib 10))))
</code></pre>
<ol start="2">
<li>Attempt to evaluate the plus function, notice that inner values need evaluation first.</li>
<li>Attempt to evaluate <code>(* (fak 5) (fak 5))</code>, again, the two inner values need evaluation first.</li>
<li>Evaluate <code>(fak 5)</code>, then again, then evaluate the result squared.</li>
<li>Etc.</li>
</ol>
<h4><a class="header" href="#applicative-order" id="applicative-order">Applicative Order</a></h4>
<p>The first reduction to perform is the inner leftmost reduction, i.e. eager evaluation, which sometimes must be controlled explicitly.</p>
<ol>
<li>Attempt to evaluate <code>(fak 5)</code>.</li>
<li>Attempt to evaluate <code>(fib 10)</code>.</li>
<li>Evaluate the function object, i.e:</li>
</ol>
<pre><code class="language-scheme">&gt; (function-object 120 55)

;;; Resulting in
(+ (* 120 120) (* 55 55))
</code></pre>
<ol start="4">
<li>Attempt to evaluate <code>(* 120 120)</code>.</li>
<li>Etc.</li>
</ol>
<h2><a class="header" href="#delayed-evaluation-and-streams" id="delayed-evaluation-and-streams">Delayed Evaluation and Streams</a></h2>
<p>Scheme is implemented with applicative-order evaluation.</p>
<h3><a class="header" href="#delayed-evaluation" id="delayed-evaluation">Delayed Evaluation</a></h3>
<p>We introduce two new primitives:</p>
<ul>
<li>Delay, and</li>
<li>Force.</li>
</ul>
<p>The following snippet describes the semantics of these primitives:</p>
<pre><code>(delay expr) =&gt; promise
(force promise) =&gt; value
</code></pre>
<p>In fact, these are easy to implement in Scheme:</p>
<pre><code class="language-scheme">(define (delay expr)
    (λ () expr))

(define (force promise)
    (promise))
</code></pre>
<h1><a class="header" href="#scheme---miniproject" id="scheme---miniproject">Scheme - Miniproject</a></h1>
<p>The Scheme miniproject is based on one of the exercises from the course.
The core concepts of the project are <em><strong>student</strong></em>, <em><strong>group</strong></em> and <em><strong>grouping</strong></em>.</p>
<blockquote>
<p>Program various ways to make project groups, in the context of PBL group work at AAU.</p>
</blockquote>
<h2><a class="header" href="#student" id="student">Student</a></h2>
<p>The structure of a student object is described in the following table.</p>
<table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td>Student-id</td><td>A unique identifier for the student.</td></tr>
<tr><td>Name</td><td>The full name of the student.</td></tr>
<tr><td>Sex</td><td>The gender, i.e. &quot;male&quot; or &quot;female&quot;.</td></tr>
<tr><td>Nationality</td><td>E.g. &quot;Danish&quot;, &quot;Icelandic&quot;.</td></tr>
</tbody></table>
<h2><a class="header" href="#group" id="group">Group</a></h2>
<p>A group ties students together with a group id. The conceptual structure is described by the following table.</p>
<table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td>Group-id</td><td>A unique identifier for the group.</td></tr>
<tr><td>Students</td><td>A list of students, or student-ids.</td></tr>
</tbody></table>
<h2><a class="header" href="#grouping" id="grouping">Grouping</a></h2>
<p>A grouping is a collection of groups. A high-level abstraction could be described by the following table.</p>
<table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td>Groups</td><td>A collection of groups, each containing a list of students.</td></tr>
</tbody></table>
<p>The problem with this structure, however, is that it cannot be sorted by students - only by groups. An alternative solution would be to create an association list, such as the following code snippet.</p>
<pre><code class="language-scheme">;; Association list. The first element is the group id,
;; the second is the student id.
((1 . a) (1 . e) (2 . b) (1 . c) (2 . d))

;; In other words
((1 (a e c)) (2 (b d)))
</code></pre>
<h2><a class="header" href="#the-assignment" id="the-assignment">The Assignment</a></h2>
<p>There exists a sample population of 200 students. For this population, write the following functions:</p>
<ul>
<li>A function that returns a given group from a grouping.
<ul>
<li>A function that returns the number of groups in a grouping</li>
<li>A function that returns the maximum group size in a grouping</li>
<li>A function that returns the minimum group size in a grouping</li>
</ul>
</li>
<li>A constructor, predicate, and selection functions for a single student.</li>
<li>A constructor, and predicate for a single group.</li>
<li>A selection function which returns the students in a group.</li>
<li>A selection function that returns the group id.</li>
<li>A predicate for a grouping.</li>
<li>Constructors for groupings.
<ul>
<li><strong>Random grouping</strong>: Given a list of students <code>sl</code> and a list of desired group sizes <code>gsl</code>, program a grouping function that forms <code>(length gsl)</code> groups, of the sizes prescribed in <code>gsl</code>. 
<ul>
<li>Assert that <code>gls</code> is a list of positive integers, whose sum is equal to <code>(length sl)</code>.</li>
<li>Should be recursive.</li>
</ul>
</li>
<li><strong>Grouping by counting</strong>: Given a list of students <code>sl</code> and a single group size <code>k</code>, iteratively assign a single group number to each student in increasing order, resetting at <code>k</code>. </li>
<li><strong>Balanced grouping by counting</strong>: Using the same parameters as the previous function, return a grouping such that there is an equal distribution of sex and ethnicity.</li>
<li><strong>Random grouping with group predicate</strong>: Using the same parameters as the random grouping function plus a predicate and a retry value, try applying the predicate on each randomly generated grouping. If the predicate fails, then reject the group, and form another random group. Each successful application of the predicate results in the group being added to the grouping. The retry value determines how many times random groups are created before the program stops.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#requirements" id="requirements">Requirements</a></h2>
<ul>
<li><em><strong>Language</strong></em>: The program must be written in Scheme</li>
<li><em><strong>Quality</strong></em>: The functional program must be well-written, well-structured and well-explained.</li>
<li><em><strong>Modularity</strong></em>: Large functions, solving large problems, must be decomposed appropriately.</li>
<li><em><strong>Purity</strong></em>: Use only pure functions, with the exception of print, file IO and random.</li>
<li><em><strong>Higher-Order Functions</strong></em>: Use them!</li>
<li><em><strong>Abstraction</strong></em>: <code>car</code> and <code>cdr</code> should be abstracted away into accessor functions for your datatypes.</li>
<li><em><strong>Comments</strong></em>: Use them to document the program.</li>
<li><em><strong>Plagiarism</strong></em>: Not allowed.</li>
</ul>
<p>The program should be unique and written alone.</p>
<h1><a class="header" href="#haskell---part-1" id="haskell---part-1">Haskell - Part 1</a></h1>
<h2><a class="header" href="#types" id="types">Types</a></h2>
<ul>
<li>Type class: A family of types who shares a property defined by the type class.
<ul>
<li>Show: Class of types whose values can be displayed</li>
<li>Eq: Class of types whose values can be compared wrt <code>=</code></li>
<li>Num: Class of number types.</li>
<li>Ord: Class of types whose values can be ordered wrt <code>&lt;</code></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#simple-types" id="simple-types">Simple Types</a></h3>
<blockquote>
<p>Types that are not composed of other types</p>
</blockquote>
<ul>
<li>Bool</li>
<li>Int</li>
</ul>
<h4><a class="header" href="#numerals" id="numerals">Numerals</a></h4>
<ul>
<li>Int</li>
<li>Integer</li>
<li>Float</li>
<li>Double</li>
</ul>
<h3><a class="header" href="#composite-types" id="composite-types">Composite Types</a></h3>
<blockquote>
<p>Types that are built with simpler types</p>
</blockquote>
<ul>
<li><code>(Bool, Int)</code></li>
<li><code>[Char]</code></li>
</ul>
<h3><a class="header" href="#simple-terms" id="simple-terms">Simple Terms</a></h3>
<h3><a class="header" href="#composite-terms" id="composite-terms">Composite Terms</a></h3>
<h2><a class="header" href="#functions" id="functions">Functions</a></h2>
<p>A lambda function is defined as follows:</p>
<pre><code class="language-haskell">\x -&gt; x + 1
</code></pre>
<p>All functions in Haskell accept only one parameter, but they can be curried.</p>
<pre><code class="language-haskell">f a = a + 1

f = \a -&gt; a + 1

f a b = a + b

f = \a -&gt; \b -&gt; a + b
</code></pre>
<p>All curried functions are higher order functions, as they accept in their body a function as a parameter.</p>
<h3><a class="header" href="#pattern-matching" id="pattern-matching">Pattern Matching</a></h3>
<p>Instead of using convoluted if expressions, we may use pattern matching.
Consider the following snippet:</p>
<pre><code class="language-haskell">f lst = if list == [] then 0 else (+ 1) . length $ tail lst

f [] = 0
f (x:xs) = ...
</code></pre>
<h3><a class="header" href="#local-declarations" id="local-declarations">Local Declarations</a></h3>
<p>Functions may be simplified by creating intermediate steps using let declarations</p>
<h4><a class="header" href="#where" id="where">Where</a></h4>
<pre><code class="language-haskell">f a b = a `plus` b
    where
        plus = (+)
</code></pre>
<h4><a class="header" href="#let" id="let">Let</a></h4>
<pre><code class="language-hs">f a b = let plus = (+) in a `plus` b
</code></pre>
<h1><a class="header" href="#haskell---part-2" id="haskell---part-2">Haskell - Part 2</a></h1>
<p>Haskell uses lazy evaluation by default.</p>
<h2><a class="header" href="#lazy-evaluation" id="lazy-evaluation">Lazy Evaluation</a></h2>
<p>Due to the default of Haskell being lazy evaluation, it has some nice properties:</p>
<ul>
<li>It is natural to define infinite structures</li>
<li>It is natural to utilize infinite structures in functions</li>
</ul>
<p>The stream of ones in Haskell is defined as:</p>
<pre><code class="language-haskell">ones = 1 : ones
</code></pre>
<h3><a class="header" href="#map-1" id="map-1">Map</a></h3>
<pre><code class="language-haskell">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>
<h3><a class="header" href="#filter-1" id="filter-1">Filter</a></h3>
<pre><code class="language-haskell">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
</code></pre>
<h3><a class="header" href="#foldl" id="foldl">Foldl</a></h3>
<pre><code class="language-haskell">foldl :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</code></pre>
<h3><a class="header" href="#foldr" id="foldr">Foldr</a></h3>
<pre><code class="language-haskell">foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</code></pre>
<h2><a class="header" href="#recursive-functions-and-datatypes" id="recursive-functions-and-datatypes">Recursive Functions and Datatypes</a></h2>
<pre><code class="language-haskell">type String = [Char]
</code></pre>
<p>In the following snippet, <code>True</code> and <code>False</code> are called term constructors.
<em>Constructors are functions.</em>
Term constructors always start with a capital letter.</p>
<pre><code class="language-haskell">data Boolean = True | False
</code></pre>
<p>A binary tree might be represented like so:</p>
<pre><code class="language-haskell">data Tree = Leaf Int | Branch Tree Tree
    deriving Show
</code></pre>
<p>In the above snippet, the Tree is recursively defined in terms of itself, or leaves.</p>
<h3><a class="header" href="#term-and-type-constructors" id="term-and-type-constructors">Term and Type Constructors</a></h3>
<p>Consider the snippet below:</p>
<pre><code class="language-haskell">data Tree a = Leaf a | Branch (Tree a, Tree a)
</code></pre>
<p><code>Tree</code> in this case is a type constructor, as it can be used to construct a tree type with a variable type a, such as <code>Tree Int</code>, where each leaf will contain an integer.
<code>Leaf</code> and <code>Branch</code>, however, are term constructors.</p>
<h3><a class="header" href="#functions-on-recursive-structures" id="functions-on-recursive-structures">Functions on Recursive Structures</a></h3>
<p>Essentially, recursive structures are naturally parsed via recursive functions and pattern matching.
The <code>Tree</code> example could be expanded to include a function which counts the number of nodes, for example.</p>
<pre><code class="language-haskell">count_nodes :: Tree -&gt; Int
count_nodes (Leaf a) = 1
count_nodes (Branch (a, b)) = (count_nodes a) + (count_nodes b)
</code></pre>
<h2><a class="header" href="#list-comprehensions-and-ranges" id="list-comprehensions-and-ranges">List Comprehensions and Ranges</a></h2>
<p>List Comprehensions make it easy to express Set Expressions.</p>
<pre><code class="language-haskell">evens = [2*i | i &lt;- [1..]]
</code></pre>
<p>Such a simple list comprehension has two parts:</p>
<ol>
<li>The function</li>
<li>The generator</li>
</ol>
<p>Basically, this works like a map function.
Given a list (created by the generator), we apply the function to each element and return the result.</p>
<p>In the case of the <code>evens</code> function, the generator is the range of all integers starting with one.
The function applied to this list is <code>i*2</code>, which neatly creates all even numbers.</p>
<p>Optionally, you may also use a guard, which is a predicate function for filtering the results of the list comprehension.
Consider the following snippet:</p>
<pre><code class="language-haskell">evensevens = [2*i | i &lt;- [1..], i `mod` 7 == 0]
</code></pre>
<h1><a class="header" href="#haskell---part-3" id="haskell---part-3">Haskell - Part 3</a></h1>
<h2><a class="header" href="#parametric-and-ad-hoc-polymorphism" id="parametric-and-ad-hoc-polymorphism">Parametric and Ad Hoc Polymorphism</a></h2>
<p>There are two kinds of Polymorphism in Haskell.
Parametric polymorphism is supported by the type system, and typified by the following snippet:</p>
<pre><code class="language-haskell">func :: a -&gt; a
</code></pre>
<p>Ad hoc polymorphism is supported by type classes, and is shown in the following snippet:</p>
<pre><code class="language-haskell">func :: Num a =&gt; a -&gt; a
</code></pre>
<h2><a class="header" href="#type-classes-in-haskell" id="type-classes-in-haskell">Type Classes in Haskell</a></h2>
<blockquote>
<p>Type Class = Family of Types
A type class in Haskell is an interface, rather than an implementation.</p>
</blockquote>
<pre><code class="language-haskell">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
</code></pre>
<p>Implementing an instance of a type class is done as follows:</p>
<pre><code class="language-haskell">instance Eq Integer where
    x == y = x `integerEq` y
</code></pre>
<p>Showing a dependency between type classes is done as follows:</p>
<pre><code class="language-haskell">instance (Eq a) =&gt; (Ord a) where
    (&lt;), (&lt;=), (&gt;=), (&gt;) :: a -&gt; a -&gt; Bool
    max, min :: a -&gt; a -&gt; a
</code></pre>
<h2><a class="header" href="#specialization-generalization-and-principal-types" id="specialization-generalization-and-principal-types">Specialization, Generalization and Principal Types</a></h2>
<p>Consider the following Lambda Calculus snippet:
Specialization is &quot;implementing&quot; a general type, i.e.</p>
<pre><code class="language-haskell">-- General type
f :: Num a =&gt; a -&gt; a

-- Specialized type
f :: Int -&gt; Int
</code></pre>
<p>A principal type is the most general type for an expression.</p>
<h2><a class="header" href="#hindley-milner-type-system" id="hindley-milner-type-system">Hindley-Milner Type System</a></h2>
<p>The HM type system contains two specialized rules: <code>project</code> and <code>close</code>, where <code>project</code> finds the specialized case, and <code>close</code> finds the general case.</p>
<h1><a class="header" href="#haskell---part-4" id="haskell---part-4">Haskell - Part 4</a></h1>
<h2><a class="header" href="#type-inference-or-the-w-algorithm" id="type-inference-or-the-w-algorithm">Type Inference, or the W Algorithm</a></h2>
<blockquote>
<p>There exists an algorithm that will take any expression <code>e</code> and attempt to compute the type of <code>e</code>.</p>
</blockquote>
<ul>
<li>Moreover: The algorithm finds a type for <code>e</code> &lt;=&gt; <code>e</code> has a type.</li>
<li>The type that the algorithm finds is the principal type of <code>e</code>.</li>
</ul>
<p>In other words, we consider parametric polymorphism.</p>
<p>The W algorithm takes an environment and an expression, returning a type.</p>
<pre><code>W(E, e) = t
</code></pre>
<p>W stands for <em>well-typed</em>.
The algorithm is recursive.</p>
<p>If the algorithm succeeds, it returns a type substitution.
Example:</p>
<pre><code>δ = [a ↦ Int, b ↦ (Bool -&gt; Bool)]
</code></pre>
<h3><a class="header" href="#unification" id="unification">Unification</a></h3>
<p>Sometimes the W algorithm will have to solve an equation over types.</p>
<p>Consider the following type equation:</p>
<pre><code class="language-haskell">a -&gt; Int = Bool -&gt; b
</code></pre>
<p>For this equation, the unifier could be:</p>
<pre><code>δ = [a ↦ Bool, b ↦ Int]
</code></pre>
<p>Resulting in:</p>
<pre><code class="language-haskell">Bool -&gt; Int
</code></pre>
<p>The Unification algorithm takes two type expressions and returns a δ, iff t_1δ = t_2δ</p>
<h3><a class="header" href="#w-algorithm" id="w-algorithm">W Algorithm</a></h3>
<p>Takes EXPTIME, that's all you need to know, innit?
Usually this is not so bad, however.</p>
<h2><a class="header" href="#type-classes-in-the-type-system" id="type-classes-in-the-type-system">Type Classes in the Type System</a></h2>
<blockquote>
<p>Types are sets of values. Type classes are sets of types.</p>
</blockquote>
<h2><a class="header" href="#io-in-haskell" id="io-in-haskell">I/O in Haskell</a></h2>
<p>Input/Output in Haskell is enabled by IO actions.
A function which gets a line from input, for example, could be implemented like so:</p>
<pre><code class="language-haskell">getLine' = do
  w &lt;- getChar
  case w of
    '\n' -&gt; return []
    _    -&gt; do
      ws &lt;- getLine'
      return (w:ws)
</code></pre>
<p>A dialog could be programmed as follows:</p>
<pre><code class="language-haskell">main = do
    w &lt;- getLine
    putStrLn $ &quot;You wrote &quot; ++ w
</code></pre>
<h1><a class="header" href="#haskell---miniproject" id="haskell---miniproject">Haskell - Miniproject</a></h1>
<p>The Haskell miniproject has the goal of implementing the Huffman encoding algorithm.</p>
<h2><a class="header" href="#the-assignment-1" id="the-assignment-1">The Assignment</a></h2>
<ul>
<li>Read an arbitrary text from input</li>
<li>Compute the optimal prefix code from input based on the frequency of its characters</li>
<li>Compress the input string and return the compressed version in an appropriate way</li>
<li>Decompress a bit sequence known to be written using a specific prefix code and write the decompressed text to output</li>
</ul>
<h1><a class="header" href="#prolog---part-1" id="prolog---part-1">Prolog - Part 1</a></h1>
<p>Prolog is a logic programming language, which is a subset of declarative programming.</p>
<blockquote>
<p>It's about the WHAT, and now the HOW.</p>
</blockquote>
<p>Prolog can be thought of as a layered language, where the simplest version is Datalog.</p>
<h2><a class="header" href="#syntax" id="syntax">Syntax</a></h2>
<p>You could split a logic program into two principles: Facts and Rules.
However, strictly speaking, </p>
<h1><a class="header" href="#prolog---part-2" id="prolog---part-2">Prolog - Part 2</a></h1>
<h1><a class="header" href="#prolog---part-3" id="prolog---part-3">Prolog - Part 3</a></h1>
<h1><a class="header" href="#prolog---part-4" id="prolog---part-4">Prolog - Part 4</a></h1>
<h1><a class="header" href="#prolog---miniproject" id="prolog---miniproject">Prolog - Miniproject</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../7_sem/dis/8_blockchain.2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../7_sem/tov/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../7_sem/dis/8_blockchain.2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../7_sem/tov/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../mermaid.min.js"></script>
        
        <script type="text/javascript" src="../../mermaid-init.js"></script>
        

        

    </body>
</html>
